class c{constructor(t){const i=t.height/2-60,s=t.map(t.random(),0,1,30,i),e=t.map(t.random(),0,1,2*-t.PI,2*t.PI);this.x=s*Math.cos(e)+t.width/2,this.y=s*Math.sin(e)+i}distance(t){if(t){const i=t.x-this.x,s=t.y-this.y;return Math.sqrt(i*i+s*s)}else return 0}draw(t,i){i?t.fill(92,202,58,80):t.fill(230),t.noStroke();const s=i||5;t.ellipse(this.x,this.y,s,s)}}class r{constructor(t,i,s=!1){this.attraction=t,this.subcolonies=[],this.t=1,this.maxt=1,this.size=i,this.root=s,this.noOutlet=!1}update(t){if(this.t>=this.maxt&&this.subcolonies.length<this.size&&t.length>0&&this.size>1&&!this.noOutlet&&!(this.root&&this.subcolonies.length>=1)){let i,s=this.root?3e3:100;for(let e of t){let n=this.attraction.distance(e);n<s&&(i=e,s=n)}i?(this.subcolonies.push(new r(i,this.size-1)),this.t=0,this.maxt=this.attraction.distance(i),t=t.filter(e=>e!==i)):this.noOutlet=!0}for(let i=0;i<this.subcolonies.length;i++){const s=this.subcolonies[i];if(i===this.subcolonies.length-1&&this.t<this.maxt)break;t=s.update(t)}return this.t<this.maxt&&(this.t+=1),t}draw(t){this.attraction.draw(t,this.size);for(let i=0;i<this.subcolonies.length;i++){const s=this.subcolonies[i];if(i===this.subcolonies.length-1&&this.t<this.maxt){const e=this.t/this.maxt,n=(s.attraction.x-this.attraction.x)*e,l=(s.attraction.y-this.attraction.y)*e;s.draw(t),t.stroke(200,100,100,80),t.strokeWeight(this.size),t.line(this.attraction.x,this.attraction.y,this.attraction.x+n,this.attraction.y+l)}else s.draw(t),t.stroke(20,140,20,80),t.strokeWeight(this.size),t.line(this.attraction.x,this.attraction.y,s.attraction.x,s.attraction.y)}}}let a=[],o;function u(){this.createCanvas(400,400),this.ellipseMode(this.RADIUS),this.noStroke(),this.strokeWeight(4);for(let h=0;h<300;h++)a.push(new c(this));o=new r(new c(this),13,!0),o.attraction.x=this.width/2,o.attraction.y=this.height-5,o.attraction.size=1}function d(){this.background(10),a=o.update(a);for(let h of a)h.draw(this);o.draw(this)}export{d as draw,u as setup};
